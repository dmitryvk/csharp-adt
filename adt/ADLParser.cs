//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 ADL.g 2015-07-22 18:20:25

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using adt.ADL;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  adt 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class ADLParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASTERISK", "ATTRIBUTES", "BASE_CLASS", "CLOSE", "COMMA", "COMMENT", "COMMON_ATTRIBUTES", "COMMON_FIELDS", "DOT", "EQ", "ID", "ID_LETTER", "ID_START_LETTER", "NAMESPACE", "OPEN", "PIPE", "PRINTED", "PRINTER", "QUESTION", "QUOTED_TEXT", "SEMI", "WALKER", "WS"
	};
	public const int EOF=-1;
	public const int ASTERISK=4;
	public const int ATTRIBUTES=5;
	public const int BASE_CLASS=6;
	public const int CLOSE=7;
	public const int COMMA=8;
	public const int COMMENT=9;
	public const int COMMON_ATTRIBUTES=10;
	public const int COMMON_FIELDS=11;
	public const int DOT=12;
	public const int EQ=13;
	public const int ID=14;
	public const int ID_LETTER=15;
	public const int ID_START_LETTER=16;
	public const int NAMESPACE=17;
	public const int OPEN=18;
	public const int PIPE=19;
	public const int PRINTED=20;
	public const int PRINTER=21;
	public const int QUESTION=22;
	public const int QUOTED_TEXT=23;
	public const int SEMI=24;
	public const int WALKER=25;
	public const int WS=26;

	public ADLParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ADLParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ADLParser.tokenNames; } }
	public override string GrammarFileName { get { return "ADL.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// ADL.g:16:8: public program returns [ProgramDecl r] : namespaceDecl baseClassDecl ( walkerDecl )? ( printerDecl )? ( node )+ EOF ;
	[GrammarRule("program")]
	public ProgramDecl program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		ProgramDecl r = default(ProgramDecl);


		NamespaceDecl namespaceDecl1 = default(NamespaceDecl);
		BaseClassDecl baseClassDecl2 = default(BaseClassDecl);
		WalkerDecl walkerDecl3 = default(WalkerDecl);
		PrinterDecl printerDecl4 = default(PrinterDecl);
		NodeDecl node5 = default(NodeDecl);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(16, 10);
		try
		{
			// ADL.g:17:5: ( namespaceDecl baseClassDecl ( walkerDecl )? ( printerDecl )? ( node )+ EOF )
			DebugEnterAlt(1);
			// ADL.g:17:7: namespaceDecl baseClassDecl ( walkerDecl )? ( printerDecl )? ( node )+ EOF
			{
			DebugLocation(17, 7);
			PushFollow(Follow._namespaceDecl_in_program57);
			namespaceDecl1=namespaceDecl();
			PopFollow();

			DebugLocation(17, 22);
			 r = new ProgramDecl { ns = namespaceDecl1 }; 
			DebugLocation(18, 5);
			PushFollow(Follow._baseClassDecl_in_program66);
			baseClassDecl2=baseClassDecl();
			PopFollow();

			DebugLocation(18, 19);
			 r.baseClass = baseClassDecl2; 
			DebugLocation(19, 5);
			// ADL.g:19:5: ( walkerDecl )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==WALKER))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:19:6: walkerDecl
				{
				DebugLocation(19, 6);
				PushFollow(Follow._walkerDecl_in_program75);
				walkerDecl3=walkerDecl();
				PopFollow();

				DebugLocation(19, 17);
				 r.walker = walkerDecl3; 

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(20, 5);
			// ADL.g:20:5: ( printerDecl )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==PRINTER))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:20:6: printerDecl
				{
				DebugLocation(20, 6);
				PushFollow(Follow._printerDecl_in_program86);
				printerDecl4=printerDecl();
				PopFollow();

				DebugLocation(20, 18);
				 r.printer = printerDecl4; 

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(21, 5);
			// ADL.g:21:5: ( node )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==ID))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// ADL.g:21:6: node
					{
					DebugLocation(21, 6);
					PushFollow(Follow._node_in_program97);
					node5=node();
					PopFollow();

					DebugLocation(22, 9);

					            r.nodes.Add(node5);
					        

					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(25, 8);
			Match(input,EOF,Follow._EOF_in_program116); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(25, 10);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return r;

	}
	// $ANTLR end "program"

	partial void EnterRule_namespaceDecl();
	partial void LeaveRule_namespaceDecl();
	// $ANTLR start "namespaceDecl"
	// ADL.g:27:1: namespaceDecl returns [NamespaceDecl r] : NAMESPACE id1= ID ( DOT id2= ID )* SEMI ;
	[GrammarRule("namespaceDecl")]
	private NamespaceDecl namespaceDecl()
	{
		EnterRule_namespaceDecl();
		EnterRule("namespaceDecl", 2);
		TraceIn("namespaceDecl", 2);
		NamespaceDecl r = default(NamespaceDecl);


		IToken id1 = default(IToken);
		IToken id2 = default(IToken);

		 r = new NamespaceDecl(); 
		try { DebugEnterRule(GrammarFileName, "namespaceDecl");
		DebugLocation(27, 95);
		try
		{
			// ADL.g:29:5: ( NAMESPACE id1= ID ( DOT id2= ID )* SEMI )
			DebugEnterAlt(1);
			// ADL.g:29:7: NAMESPACE id1= ID ( DOT id2= ID )* SEMI
			{
			DebugLocation(29, 7);
			Match(input,NAMESPACE,Follow._NAMESPACE_in_namespaceDecl137); 
			DebugLocation(29, 20);
			id1=(IToken)Match(input,ID,Follow._ID_in_namespaceDecl141); 
			DebugLocation(29, 24);
			 r.ids.Add((id1!=null?id1.Text:default(string))); 
			DebugLocation(29, 51);
			// ADL.g:29:51: ( DOT id2= ID )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==DOT))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// ADL.g:29:52: DOT id2= ID
					{
					DebugLocation(29, 52);
					Match(input,DOT,Follow._DOT_in_namespaceDecl146); 
					DebugLocation(29, 59);
					id2=(IToken)Match(input,ID,Follow._ID_in_namespaceDecl150); 
					DebugLocation(29, 63);
					 r.ids.Add((id2!=null?id2.Text:default(string))); 

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(29, 92);
			Match(input,SEMI,Follow._SEMI_in_namespaceDecl156); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("namespaceDecl", 2);
			LeaveRule("namespaceDecl", 2);
			LeaveRule_namespaceDecl();
		}
		DebugLocation(29, 95);
		} finally { DebugExitRule(GrammarFileName, "namespaceDecl"); }
		return r;

	}
	// $ANTLR end "namespaceDecl"

	partial void EnterRule_baseClassDecl();
	partial void LeaveRule_baseClassDecl();
	// $ANTLR start "baseClassDecl"
	// ADL.g:31:1: baseClassDecl returns [BaseClassDecl r] : BASE_CLASS ID SEMI ;
	[GrammarRule("baseClassDecl")]
	private BaseClassDecl baseClassDecl()
	{
		EnterRule_baseClassDecl();
		EnterRule("baseClassDecl", 3);
		TraceIn("baseClassDecl", 3);
		BaseClassDecl r = default(BaseClassDecl);


		IToken ID6 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "baseClassDecl");
		DebugLocation(31, 4);
		try
		{
			// ADL.g:32:5: ( BASE_CLASS ID SEMI )
			DebugEnterAlt(1);
			// ADL.g:32:7: BASE_CLASS ID SEMI
			{
			DebugLocation(32, 7);
			Match(input,BASE_CLASS,Follow._BASE_CLASS_in_baseClassDecl172); 
			DebugLocation(32, 18);
			ID6=(IToken)Match(input,ID,Follow._ID_in_baseClassDecl174); 
			DebugLocation(32, 21);
			Match(input,SEMI,Follow._SEMI_in_baseClassDecl176); 
			DebugLocation(33, 5);
			 r = new BaseClassDecl { name = (ID6!=null?ID6.Text:default(string)) }; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("baseClassDecl", 3);
			LeaveRule("baseClassDecl", 3);
			LeaveRule_baseClassDecl();
		}
		DebugLocation(34, 4);
		} finally { DebugExitRule(GrammarFileName, "baseClassDecl"); }
		return r;

	}
	// $ANTLR end "baseClassDecl"

	partial void EnterRule_walkerDecl();
	partial void LeaveRule_walkerDecl();
	// $ANTLR start "walkerDecl"
	// ADL.g:36:1: walkerDecl returns [WalkerDecl r] : WALKER ID SEMI ;
	[GrammarRule("walkerDecl")]
	private WalkerDecl walkerDecl()
	{
		EnterRule_walkerDecl();
		EnterRule("walkerDecl", 4);
		TraceIn("walkerDecl", 4);
		WalkerDecl r = default(WalkerDecl);


		IToken ID7 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "walkerDecl");
		DebugLocation(36, 4);
		try
		{
			// ADL.g:37:5: ( WALKER ID SEMI )
			DebugEnterAlt(1);
			// ADL.g:37:7: WALKER ID SEMI
			{
			DebugLocation(37, 7);
			Match(input,WALKER,Follow._WALKER_in_walkerDecl203); 
			DebugLocation(37, 14);
			ID7=(IToken)Match(input,ID,Follow._ID_in_walkerDecl205); 
			DebugLocation(37, 17);
			Match(input,SEMI,Follow._SEMI_in_walkerDecl207); 
			DebugLocation(38, 5);
			 r = new WalkerDecl { name = (ID7!=null?ID7.Text:default(string)) }; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("walkerDecl", 4);
			LeaveRule("walkerDecl", 4);
			LeaveRule_walkerDecl();
		}
		DebugLocation(39, 4);
		} finally { DebugExitRule(GrammarFileName, "walkerDecl"); }
		return r;

	}
	// $ANTLR end "walkerDecl"

	partial void EnterRule_printerDecl();
	partial void LeaveRule_printerDecl();
	// $ANTLR start "printerDecl"
	// ADL.g:41:1: printerDecl returns [PrinterDecl r] : PRINTER name= ID root= ID SEMI ;
	[GrammarRule("printerDecl")]
	private PrinterDecl printerDecl()
	{
		EnterRule_printerDecl();
		EnterRule("printerDecl", 5);
		TraceIn("printerDecl", 5);
		PrinterDecl r = default(PrinterDecl);


		IToken name = default(IToken);
		IToken root = default(IToken);

		try { DebugEnterRule(GrammarFileName, "printerDecl");
		DebugLocation(41, 4);
		try
		{
			// ADL.g:42:5: ( PRINTER name= ID root= ID SEMI )
			DebugEnterAlt(1);
			// ADL.g:42:7: PRINTER name= ID root= ID SEMI
			{
			DebugLocation(42, 7);
			Match(input,PRINTER,Follow._PRINTER_in_printerDecl234); 
			DebugLocation(42, 19);
			name=(IToken)Match(input,ID,Follow._ID_in_printerDecl238); 
			DebugLocation(42, 27);
			root=(IToken)Match(input,ID,Follow._ID_in_printerDecl242); 
			DebugLocation(42, 31);
			Match(input,SEMI,Follow._SEMI_in_printerDecl244); 
			DebugLocation(43, 5);
			 r = new PrinterDecl { name = (name!=null?name.Text:default(string)), root = (root!=null?root.Text:default(string)) }; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("printerDecl", 5);
			LeaveRule("printerDecl", 5);
			LeaveRule_printerDecl();
		}
		DebugLocation(44, 4);
		} finally { DebugExitRule(GrammarFileName, "printerDecl"); }
		return r;

	}
	// $ANTLR end "printerDecl"

	partial void EnterRule_node();
	partial void LeaveRule_node();
	// $ANTLR start "node"
	// ADL.g:46:1: node returns [NodeDecl r] : ( nodeVariants | nodeConcrete );
	[GrammarRule("node")]
	private NodeDecl node()
	{
		EnterRule_node();
		EnterRule("node", 6);
		TraceIn("node", 6);
		NodeDecl r = default(NodeDecl);


		NodeVariantsDecl nodeVariants8 = default(NodeVariantsDecl);
		NodeConcreteDecl nodeConcrete9 = default(NodeConcreteDecl);

		try { DebugEnterRule(GrammarFileName, "node");
		DebugLocation(46, 85);
		try
		{
			// ADL.g:47:5: ( nodeVariants | nodeConcrete )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==ID))
			{
				int LA5_2 = input.LA(2);

				if ((LA5_2==EQ))
				{
					switch (input.LA(3))
					{
					case COMMON_FIELDS:
						{
						alt5 = 1;
						}
						break;
					case ID:
						{
						int LA5_4 = input.LA(4);

						if ((LA5_4==OPEN))
						{
							alt5 = 1;
						}
						else if (((LA5_4>=ASTERISK && LA5_4<=ATTRIBUTES)||LA5_4==COMMA||LA5_4==ID||LA5_4==QUESTION||LA5_4==SEMI))
						{
							alt5 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 5, 4, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case ATTRIBUTES:
					case SEMI:
						{
						alt5 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 5, 2, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:47:7: nodeVariants
				{
				DebugLocation(47, 7);
				PushFollow(Follow._nodeVariants_in_node271);
				nodeVariants8=nodeVariants();
				PopFollow();

				DebugLocation(47, 20);
				 r = nodeVariants8; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ADL.g:47:48: nodeConcrete
				{
				DebugLocation(47, 48);
				PushFollow(Follow._nodeConcrete_in_node277);
				nodeConcrete9=nodeConcrete();
				PopFollow();

				DebugLocation(47, 61);
				 r = nodeConcrete9; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("node", 6);
			LeaveRule("node", 6);
			LeaveRule_node();
		}
		DebugLocation(47, 85);
		} finally { DebugExitRule(GrammarFileName, "node"); }
		return r;

	}
	// $ANTLR end "node"

	partial void EnterRule_nodeVariants();
	partial void LeaveRule_nodeVariants();
	// $ANTLR start "nodeVariants"
	// ADL.g:49:1: nodeVariants returns [NodeVariantsDecl r] : ID EQ (c= commonFields )? v1= nodeVariant ( PIPE v2= nodeVariant )* (c= commonFields )? ( common_attributes )? SEMI ;
	[GrammarRule("nodeVariants")]
	private NodeVariantsDecl nodeVariants()
	{
		EnterRule_nodeVariants();
		EnterRule("nodeVariants", 7);
		TraceIn("nodeVariants", 7);
		NodeVariantsDecl r = default(NodeVariantsDecl);


		IToken ID10 = default(IToken);
		List<FieldDecl> c = default(List<FieldDecl>);
		NodeVariantDecl v1 = default(NodeVariantDecl);
		NodeVariantDecl v2 = default(NodeVariantDecl);
		List<AttributeDecl> common_attributes11 = default(List<AttributeDecl>);

		try { DebugEnterRule(GrammarFileName, "nodeVariants");
		DebugLocation(49, 8);
		try
		{
			// ADL.g:50:5: ( ID EQ (c= commonFields )? v1= nodeVariant ( PIPE v2= nodeVariant )* (c= commonFields )? ( common_attributes )? SEMI )
			DebugEnterAlt(1);
			// ADL.g:50:7: ID EQ (c= commonFields )? v1= nodeVariant ( PIPE v2= nodeVariant )* (c= commonFields )? ( common_attributes )? SEMI
			{
			DebugLocation(50, 7);
			ID10=(IToken)Match(input,ID,Follow._ID_in_nodeVariants299); 
			DebugLocation(50, 10);
			Match(input,EQ,Follow._EQ_in_nodeVariants301); 
			DebugLocation(50, 13);
			 r = new NodeVariantsDecl { id = (ID10!=null?ID10.Text:default(string)) }; 
			DebugLocation(51, 5);
			// ADL.g:51:5: (c= commonFields )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==COMMON_FIELDS))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:52:9: c= commonFields
				{
				DebugLocation(52, 10);
				PushFollow(Follow._commonFields_in_nodeVariants321);
				c=commonFields();
				PopFollow();

				DebugLocation(53, 9);

				            r.commonFieldsBefore = c;
				        

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(57, 7);
			PushFollow(Follow._nodeVariant_in_nodeVariants346);
			v1=nodeVariant();
			PopFollow();

			DebugLocation(57, 20);
			 r.variants.Add(v1); 
			DebugLocation(57, 48);
			// ADL.g:57:48: ( PIPE v2= nodeVariant )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==PIPE))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// ADL.g:57:49: PIPE v2= nodeVariant
					{
					DebugLocation(57, 49);
					Match(input,PIPE,Follow._PIPE_in_nodeVariants351); 
					DebugLocation(57, 56);
					PushFollow(Follow._nodeVariant_in_nodeVariants355);
					v2=nodeVariant();
					PopFollow();

					DebugLocation(57, 69);
					 r.variants.Add(v2); 

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(58, 5);
			// ADL.g:58:5: (c= commonFields )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==COMMON_FIELDS))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:59:9: c= commonFields
				{
				DebugLocation(59, 10);
				PushFollow(Follow._commonFields_in_nodeVariants377);
				c=commonFields();
				PopFollow();

				DebugLocation(60, 9);

				            r.commonFieldsAfter = c;
				        

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(64, 5);
			// ADL.g:64:5: ( common_attributes )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==COMMON_ATTRIBUTES))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:64:5: common_attributes
				{
				DebugLocation(64, 5);
				PushFollow(Follow._common_attributes_in_nodeVariants400);
				common_attributes11=common_attributes();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(65, 5);

			        r.attributes = common_attributes11 ?? new List<AttributeDecl>();
			    
			DebugLocation(68, 5);
			Match(input,SEMI,Follow._SEMI_in_nodeVariants413); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("nodeVariants", 7);
			LeaveRule("nodeVariants", 7);
			LeaveRule_nodeVariants();
		}
		DebugLocation(68, 8);
		} finally { DebugExitRule(GrammarFileName, "nodeVariants"); }
		return r;

	}
	// $ANTLR end "nodeVariants"

	partial void EnterRule_commonFields();
	partial void LeaveRule_commonFields();
	// $ANTLR start "commonFields"
	// ADL.g:70:1: commonFields returns [List<FieldDecl> r] : COMMON_FIELDS OPEN ( fields )? CLOSE ;
	[GrammarRule("commonFields")]
	private List<FieldDecl> commonFields()
	{
		EnterRule_commonFields();
		EnterRule("commonFields", 8);
		TraceIn("commonFields", 8);
		List<FieldDecl> r = default(List<FieldDecl>);


		List<FieldDecl> fields12 = default(List<FieldDecl>);

		try { DebugEnterRule(GrammarFileName, "commonFields");
		DebugLocation(70, 5);
		try
		{
			// ADL.g:71:5: ( COMMON_FIELDS OPEN ( fields )? CLOSE )
			DebugEnterAlt(1);
			// ADL.g:71:7: COMMON_FIELDS OPEN ( fields )? CLOSE
			{
			DebugLocation(71, 7);
			Match(input,COMMON_FIELDS,Follow._COMMON_FIELDS_in_commonFields429); 
			DebugLocation(71, 21);
			Match(input,OPEN,Follow._OPEN_in_commonFields431); 
			DebugLocation(71, 26);
			// ADL.g:71:26: ( fields )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==ID))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:71:26: fields
				{
				DebugLocation(71, 26);
				PushFollow(Follow._fields_in_commonFields433);
				fields12=fields();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(71, 34);
			Match(input,CLOSE,Follow._CLOSE_in_commonFields436); 
			DebugLocation(72, 5);

			        r = fields12 ?? new List<FieldDecl>();
			    

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("commonFields", 8);
			LeaveRule("commonFields", 8);
			LeaveRule_commonFields();
		}
		DebugLocation(74, 5);
		} finally { DebugExitRule(GrammarFileName, "commonFields"); }
		return r;

	}
	// $ANTLR end "commonFields"

	partial void EnterRule_nodeVariant();
	partial void LeaveRule_nodeVariant();
	// $ANTLR start "nodeVariant"
	// ADL.g:76:1: nodeVariant returns [NodeVariantDecl r] : ID OPEN ( fields )? CLOSE ( attributes )? ;
	[GrammarRule("nodeVariant")]
	private NodeVariantDecl nodeVariant()
	{
		EnterRule_nodeVariant();
		EnterRule("nodeVariant", 9);
		TraceIn("nodeVariant", 9);
		NodeVariantDecl r = default(NodeVariantDecl);


		IToken ID13 = default(IToken);
		List<FieldDecl> fields14 = default(List<FieldDecl>);
		List<AttributeDecl> attributes15 = default(List<AttributeDecl>);

		try { DebugEnterRule(GrammarFileName, "nodeVariant");
		DebugLocation(76, 4);
		try
		{
			// ADL.g:77:5: ( ID OPEN ( fields )? CLOSE ( attributes )? )
			DebugEnterAlt(1);
			// ADL.g:77:7: ID OPEN ( fields )? CLOSE ( attributes )?
			{
			DebugLocation(77, 7);
			ID13=(IToken)Match(input,ID,Follow._ID_in_nodeVariant458); 
			DebugLocation(77, 10);
			Match(input,OPEN,Follow._OPEN_in_nodeVariant460); 
			DebugLocation(77, 15);
			// ADL.g:77:15: ( fields )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==ID))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:77:15: fields
				{
				DebugLocation(77, 15);
				PushFollow(Follow._fields_in_nodeVariant462);
				fields14=fields();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(77, 23);
			Match(input,CLOSE,Follow._CLOSE_in_nodeVariant465); 
			DebugLocation(77, 29);
			// ADL.g:77:29: ( attributes )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==ATTRIBUTES))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:77:29: attributes
				{
				DebugLocation(77, 29);
				PushFollow(Follow._attributes_in_nodeVariant467);
				attributes15=attributes();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(78, 4);
			 r = new NodeVariantDecl 
			       { id = (ID13!=null?ID13.Text:default(string)),
			        fields = fields14 ?? new List<FieldDecl>(),
			        attributes = attributes15 ?? new List<AttributeDecl>()
			       };
			   

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("nodeVariant", 9);
			LeaveRule("nodeVariant", 9);
			LeaveRule_nodeVariant();
		}
		DebugLocation(83, 4);
		} finally { DebugExitRule(GrammarFileName, "nodeVariant"); }
		return r;

	}
	// $ANTLR end "nodeVariant"

	partial void EnterRule_nodeConcrete();
	partial void LeaveRule_nodeConcrete();
	// $ANTLR start "nodeConcrete"
	// ADL.g:85:1: nodeConcrete returns [NodeConcreteDecl r] : ID EQ ( fields )? ( attributes )? SEMI ;
	[GrammarRule("nodeConcrete")]
	private NodeConcreteDecl nodeConcrete()
	{
		EnterRule_nodeConcrete();
		EnterRule("nodeConcrete", 10);
		TraceIn("nodeConcrete", 10);
		NodeConcreteDecl r = default(NodeConcreteDecl);


		IToken ID16 = default(IToken);
		List<FieldDecl> fields17 = default(List<FieldDecl>);
		List<AttributeDecl> attributes18 = default(List<AttributeDecl>);

		try { DebugEnterRule(GrammarFileName, "nodeConcrete");
		DebugLocation(85, 9);
		try
		{
			// ADL.g:86:5: ( ID EQ ( fields )? ( attributes )? SEMI )
			DebugEnterAlt(1);
			// ADL.g:86:7: ID EQ ( fields )? ( attributes )? SEMI
			{
			DebugLocation(86, 7);
			ID16=(IToken)Match(input,ID,Follow._ID_in_nodeConcrete489); 
			DebugLocation(86, 10);
			Match(input,EQ,Follow._EQ_in_nodeConcrete491); 
			DebugLocation(86, 13);
			// ADL.g:86:13: ( fields )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==ID))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:86:13: fields
				{
				DebugLocation(86, 13);
				PushFollow(Follow._fields_in_nodeConcrete493);
				fields17=fields();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(86, 21);
			// ADL.g:86:21: ( attributes )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==ATTRIBUTES))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:86:21: attributes
				{
				DebugLocation(86, 21);
				PushFollow(Follow._attributes_in_nodeConcrete496);
				attributes18=attributes();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(87, 4);
			 r = new NodeConcreteDecl 
			       { id = (ID16!=null?ID16.Text:default(string)),
			        fields = fields17 ?? new List<FieldDecl>(),
			        attributes = attributes18 ?? new List<AttributeDecl>()
			       };
			   
			DebugLocation(92, 6);
			Match(input,SEMI,Follow._SEMI_in_nodeConcrete504); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("nodeConcrete", 10);
			LeaveRule("nodeConcrete", 10);
			LeaveRule_nodeConcrete();
		}
		DebugLocation(92, 9);
		} finally { DebugExitRule(GrammarFileName, "nodeConcrete"); }
		return r;

	}
	// $ANTLR end "nodeConcrete"

	partial void EnterRule_fields();
	partial void LeaveRule_fields();
	// $ANTLR start "fields"
	// ADL.g:94:1: fields returns [List<FieldDecl> r] : f1= field ( COMMA f2= field )* ;
	[GrammarRule("fields")]
	private List<FieldDecl> fields()
	{
		EnterRule_fields();
		EnterRule("fields", 11);
		TraceIn("fields", 11);
		List<FieldDecl> r = default(List<FieldDecl>);


		FieldDecl f1 = default(FieldDecl);
		FieldDecl f2 = default(FieldDecl);

		 r = new List<FieldDecl>(); 
		try { DebugEnterRule(GrammarFileName, "fields");
		DebugLocation(94, 70);
		try
		{
			// ADL.g:96:5: (f1= field ( COMMA f2= field )* )
			DebugEnterAlt(1);
			// ADL.g:96:7: f1= field ( COMMA f2= field )*
			{
			DebugLocation(96, 9);
			PushFollow(Follow._field_in_fields531);
			f1=field();
			PopFollow();

			DebugLocation(96, 16);
			 r.Add(f1); 
			DebugLocation(96, 35);
			// ADL.g:96:35: ( COMMA f2= field )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==COMMA))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// ADL.g:96:36: COMMA f2= field
					{
					DebugLocation(96, 36);
					Match(input,COMMA,Follow._COMMA_in_fields536); 
					DebugLocation(96, 44);
					PushFollow(Follow._field_in_fields540);
					f2=field();
					PopFollow();

					DebugLocation(96, 51);
					 r.Add(f2); 

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("fields", 11);
			LeaveRule("fields", 11);
			LeaveRule_fields();
		}
		DebugLocation(96, 70);
		} finally { DebugExitRule(GrammarFileName, "fields"); }
		return r;

	}
	// $ANTLR end "fields"

	partial void EnterRule_attributes();
	partial void LeaveRule_attributes();
	// $ANTLR start "attributes"
	// ADL.g:98:1: attributes returns [List<AttributeDecl> r] : ATTRIBUTES a1= attributeDecl ( COMMA a2= attributeDecl )* ;
	[GrammarRule("attributes")]
	private List<AttributeDecl> attributes()
	{
		EnterRule_attributes();
		EnterRule("attributes", 12);
		TraceIn("attributes", 12);
		List<AttributeDecl> r = default(List<AttributeDecl>);


		AttributeDecl a1 = default(AttributeDecl);
		AttributeDecl a2 = default(AttributeDecl);

		 r = new List<AttributeDecl>(); 
		try { DebugEnterRule(GrammarFileName, "attributes");
		DebugLocation(98, 97);
		try
		{
			// ADL.g:100:5: ( ATTRIBUTES a1= attributeDecl ( COMMA a2= attributeDecl )* )
			DebugEnterAlt(1);
			// ADL.g:100:7: ATTRIBUTES a1= attributeDecl ( COMMA a2= attributeDecl )*
			{
			DebugLocation(100, 7);
			Match(input,ATTRIBUTES,Follow._ATTRIBUTES_in_attributes565); 
			DebugLocation(100, 20);
			PushFollow(Follow._attributeDecl_in_attributes569);
			a1=attributeDecl();
			PopFollow();

			DebugLocation(100, 35);
			 r.Add(a1); 
			DebugLocation(100, 54);
			// ADL.g:100:54: ( COMMA a2= attributeDecl )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==COMMA))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// ADL.g:100:55: COMMA a2= attributeDecl
					{
					DebugLocation(100, 55);
					Match(input,COMMA,Follow._COMMA_in_attributes574); 
					DebugLocation(100, 63);
					PushFollow(Follow._attributeDecl_in_attributes578);
					a2=attributeDecl();
					PopFollow();

					DebugLocation(100, 78);
					 r.Add(a2); 

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attributes", 12);
			LeaveRule("attributes", 12);
			LeaveRule_attributes();
		}
		DebugLocation(100, 97);
		} finally { DebugExitRule(GrammarFileName, "attributes"); }
		return r;

	}
	// $ANTLR end "attributes"

	partial void EnterRule_common_attributes();
	partial void LeaveRule_common_attributes();
	// $ANTLR start "common_attributes"
	// ADL.g:102:1: common_attributes returns [List<AttributeDecl> r] : COMMON_ATTRIBUTES a1= attributeDecl ( COMMA a2= attributeDecl )* ;
	[GrammarRule("common_attributes")]
	private List<AttributeDecl> common_attributes()
	{
		EnterRule_common_attributes();
		EnterRule("common_attributes", 13);
		TraceIn("common_attributes", 13);
		List<AttributeDecl> r = default(List<AttributeDecl>);


		AttributeDecl a1 = default(AttributeDecl);
		AttributeDecl a2 = default(AttributeDecl);

		 r = new List<AttributeDecl>(); 
		try { DebugEnterRule(GrammarFileName, "common_attributes");
		DebugLocation(102, 104);
		try
		{
			// ADL.g:104:5: ( COMMON_ATTRIBUTES a1= attributeDecl ( COMMA a2= attributeDecl )* )
			DebugEnterAlt(1);
			// ADL.g:104:7: COMMON_ATTRIBUTES a1= attributeDecl ( COMMA a2= attributeDecl )*
			{
			DebugLocation(104, 7);
			Match(input,COMMON_ATTRIBUTES,Follow._COMMON_ATTRIBUTES_in_common_attributes603); 
			DebugLocation(104, 27);
			PushFollow(Follow._attributeDecl_in_common_attributes607);
			a1=attributeDecl();
			PopFollow();

			DebugLocation(104, 42);
			 r.Add(a1); 
			DebugLocation(104, 61);
			// ADL.g:104:61: ( COMMA a2= attributeDecl )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==COMMA))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// ADL.g:104:62: COMMA a2= attributeDecl
					{
					DebugLocation(104, 62);
					Match(input,COMMA,Follow._COMMA_in_common_attributes612); 
					DebugLocation(104, 70);
					PushFollow(Follow._attributeDecl_in_common_attributes616);
					a2=attributeDecl();
					PopFollow();

					DebugLocation(104, 85);
					 r.Add(a2); 

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("common_attributes", 13);
			LeaveRule("common_attributes", 13);
			LeaveRule_common_attributes();
		}
		DebugLocation(104, 104);
		} finally { DebugExitRule(GrammarFileName, "common_attributes"); }
		return r;

	}
	// $ANTLR end "common_attributes"

	partial void EnterRule_field();
	partial void LeaveRule_field();
	// $ANTLR start "field"
	// ADL.g:106:1: field returns [FieldDecl r] : typeId= ID (q= QUESTION |a= ASTERISK )? (nameId= ID )? ;
	[GrammarRule("field")]
	private FieldDecl field()
	{
		EnterRule_field();
		EnterRule("field", 14);
		TraceIn("field", 14);
		FieldDecl r = default(FieldDecl);


		IToken typeId = default(IToken);
		IToken q = default(IToken);
		IToken a = default(IToken);
		IToken nameId = default(IToken);

		try { DebugEnterRule(GrammarFileName, "field");
		DebugLocation(106, 5);
		try
		{
			// ADL.g:107:5: (typeId= ID (q= QUESTION |a= ASTERISK )? (nameId= ID )? )
			DebugEnterAlt(1);
			// ADL.g:107:7: typeId= ID (q= QUESTION |a= ASTERISK )? (nameId= ID )?
			{
			DebugLocation(107, 13);
			typeId=(IToken)Match(input,ID,Follow._ID_in_field642); 
			DebugLocation(107, 17);
			// ADL.g:107:17: (q= QUESTION |a= ASTERISK )?
			int alt18=3;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==QUESTION))
			{
				alt18 = 1;
			}
			else if ((LA18_1==ASTERISK))
			{
				alt18 = 2;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:107:18: q= QUESTION
				{
				DebugLocation(107, 19);
				q=(IToken)Match(input,QUESTION,Follow._QUESTION_in_field647); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ADL.g:107:29: a= ASTERISK
				{
				DebugLocation(107, 30);
				a=(IToken)Match(input,ASTERISK,Follow._ASTERISK_in_field651); 

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(107, 48);
			// ADL.g:107:48: (nameId= ID )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==ID))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:107:48: nameId= ID
				{
				DebugLocation(107, 48);
				nameId=(IToken)Match(input,ID,Follow._ID_in_field657); 

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(107, 53);

			    r = new FieldDecl {
			    type = (typeId!=null?typeId.Text:default(string)), id = (nameId!=null?nameId.Text:default(string)) ?? (typeId!=null?typeId.Text:default(string)), optional = q != null, many = a != null    };
			    

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("field", 14);
			LeaveRule("field", 14);
			LeaveRule_field();
		}
		DebugLocation(110, 5);
		} finally { DebugExitRule(GrammarFileName, "field"); }
		return r;

	}
	// $ANTLR end "field"

	partial void EnterRule_attributeDecl();
	partial void LeaveRule_attributeDecl();
	// $ANTLR start "attributeDecl"
	// ADL.g:112:1: attributeDecl returns [AttributeDecl r] : ( PRINTED )? attrType ID ;
	[GrammarRule("attributeDecl")]
	private AttributeDecl attributeDecl()
	{
		EnterRule_attributeDecl();
		EnterRule("attributeDecl", 15);
		TraceIn("attributeDecl", 15);
		AttributeDecl r = default(AttributeDecl);


		IToken ID19 = default(IToken);
		IToken PRINTED21 = default(IToken);
		string attrType20 = default(string);

		try { DebugEnterRule(GrammarFileName, "attributeDecl");
		DebugLocation(112, 120);
		try
		{
			// ADL.g:113:5: ( ( PRINTED )? attrType ID )
			DebugEnterAlt(1);
			// ADL.g:113:7: ( PRINTED )? attrType ID
			{
			DebugLocation(113, 7);
			// ADL.g:113:7: ( PRINTED )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==PRINTED))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:113:7: PRINTED
				{
				DebugLocation(113, 7);
				PRINTED21=(IToken)Match(input,PRINTED,Follow._PRINTED_in_attributeDecl676); 

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(113, 16);
			PushFollow(Follow._attrType_in_attributeDecl679);
			attrType20=attrType();
			PopFollow();

			DebugLocation(113, 25);
			ID19=(IToken)Match(input,ID,Follow._ID_in_attributeDecl681); 
			DebugLocation(113, 28);
			 r = new AttributeDecl { id = (ID19!=null?ID19.Text:default(string)), type = attrType20, printed = PRINTED21 != null }; 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attributeDecl", 15);
			LeaveRule("attributeDecl", 15);
			LeaveRule_attributeDecl();
		}
		DebugLocation(113, 120);
		} finally { DebugExitRule(GrammarFileName, "attributeDecl"); }
		return r;

	}
	// $ANTLR end "attributeDecl"

	partial void EnterRule_attrType();
	partial void LeaveRule_attrType();
	// $ANTLR start "attrType"
	// ADL.g:115:1: attrType returns [string r] : (id1= ID ( DOT id2= ID )* | QUOTED_TEXT );
	[GrammarRule("attrType")]
	private string attrType()
	{
		EnterRule_attrType();
		EnterRule("attrType", 16);
		TraceIn("attrType", 16);
		string r = default(string);


		IToken id1 = default(IToken);
		IToken id2 = default(IToken);
		IToken QUOTED_TEXT22 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "attrType");
		DebugLocation(115, 88);
		try
		{
			// ADL.g:116:5: (id1= ID ( DOT id2= ID )* | QUOTED_TEXT )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if ((LA22_1==ID))
			{
				alt22 = 1;
			}
			else if ((LA22_1==QUOTED_TEXT))
			{
				alt22 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// ADL.g:116:7: id1= ID ( DOT id2= ID )*
				{
				DebugLocation(116, 10);
				id1=(IToken)Match(input,ID,Follow._ID_in_attrType701); 
				DebugLocation(116, 14);
				 r = (id1!=null?id1.Text:default(string)); 
				DebugLocation(116, 34);
				// ADL.g:116:34: ( DOT id2= ID )*
				try { DebugEnterSubRule(21);
				while (true)
				{
					int alt21=2;
					try { DebugEnterDecision(21, false);
					int LA21_1 = input.LA(1);

					if ((LA21_1==DOT))
					{
						alt21 = 1;
					}


					} finally { DebugExitDecision(21); }
					switch ( alt21 )
					{
					case 1:
						DebugEnterAlt(1);
						// ADL.g:116:35: DOT id2= ID
						{
						DebugLocation(116, 35);
						Match(input,DOT,Follow._DOT_in_attrType706); 
						DebugLocation(116, 42);
						id2=(IToken)Match(input,ID,Follow._ID_in_attrType710); 
						DebugLocation(116, 46);
						 r = r + "." + (id2!=null?id2.Text:default(string)); 

						}
						break;

					default:
						goto loop21;
					}
				}

				loop21:
					;

				} finally { DebugExitSubRule(21); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ADL.g:117:7: QUOTED_TEXT
				{
				DebugLocation(117, 7);
				QUOTED_TEXT22=(IToken)Match(input,QUOTED_TEXT,Follow._QUOTED_TEXT_in_attrType722); 
				DebugLocation(117, 19);
				 r = (QUOTED_TEXT22!=null?QUOTED_TEXT22.Text:default(string)).Substring(1, (QUOTED_TEXT22!=null?QUOTED_TEXT22.Text:default(string)).Length - 2); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attrType", 16);
			LeaveRule("attrType", 16);
			LeaveRule_attrType();
		}
		DebugLocation(117, 88);
		} finally { DebugExitRule(GrammarFileName, "attrType"); }
		return r;

	}
	// $ANTLR end "attrType"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _namespaceDecl_in_program57 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _baseClassDecl_in_program66 = new BitSet(new ulong[]{0x2204000UL});
		public static readonly BitSet _walkerDecl_in_program75 = new BitSet(new ulong[]{0x204000UL});
		public static readonly BitSet _printerDecl_in_program86 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _node_in_program97 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program116 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAMESPACE_in_namespaceDecl137 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_namespaceDecl141 = new BitSet(new ulong[]{0x1001000UL});
		public static readonly BitSet _DOT_in_namespaceDecl146 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_namespaceDecl150 = new BitSet(new ulong[]{0x1001000UL});
		public static readonly BitSet _SEMI_in_namespaceDecl156 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BASE_CLASS_in_baseClassDecl172 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_baseClassDecl174 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _SEMI_in_baseClassDecl176 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WALKER_in_walkerDecl203 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_walkerDecl205 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _SEMI_in_walkerDecl207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PRINTER_in_printerDecl234 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_printerDecl238 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_printerDecl242 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _SEMI_in_printerDecl244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nodeVariants_in_node271 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nodeConcrete_in_node277 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_nodeVariants299 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _EQ_in_nodeVariants301 = new BitSet(new ulong[]{0x4800UL});
		public static readonly BitSet _commonFields_in_nodeVariants321 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _nodeVariant_in_nodeVariants346 = new BitSet(new ulong[]{0x1080C00UL});
		public static readonly BitSet _PIPE_in_nodeVariants351 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _nodeVariant_in_nodeVariants355 = new BitSet(new ulong[]{0x1080C00UL});
		public static readonly BitSet _commonFields_in_nodeVariants377 = new BitSet(new ulong[]{0x1000400UL});
		public static readonly BitSet _common_attributes_in_nodeVariants400 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _SEMI_in_nodeVariants413 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMON_FIELDS_in_commonFields429 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _OPEN_in_commonFields431 = new BitSet(new ulong[]{0x4080UL});
		public static readonly BitSet _fields_in_commonFields433 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _CLOSE_in_commonFields436 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_nodeVariant458 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _OPEN_in_nodeVariant460 = new BitSet(new ulong[]{0x4080UL});
		public static readonly BitSet _fields_in_nodeVariant462 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _CLOSE_in_nodeVariant465 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _attributes_in_nodeVariant467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_nodeConcrete489 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _EQ_in_nodeConcrete491 = new BitSet(new ulong[]{0x1004020UL});
		public static readonly BitSet _fields_in_nodeConcrete493 = new BitSet(new ulong[]{0x1000020UL});
		public static readonly BitSet _attributes_in_nodeConcrete496 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _SEMI_in_nodeConcrete504 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _field_in_fields531 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _COMMA_in_fields536 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _field_in_fields540 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _ATTRIBUTES_in_attributes565 = new BitSet(new ulong[]{0x904000UL});
		public static readonly BitSet _attributeDecl_in_attributes569 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _COMMA_in_attributes574 = new BitSet(new ulong[]{0x904000UL});
		public static readonly BitSet _attributeDecl_in_attributes578 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _COMMON_ATTRIBUTES_in_common_attributes603 = new BitSet(new ulong[]{0x904000UL});
		public static readonly BitSet _attributeDecl_in_common_attributes607 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _COMMA_in_common_attributes612 = new BitSet(new ulong[]{0x904000UL});
		public static readonly BitSet _attributeDecl_in_common_attributes616 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _ID_in_field642 = new BitSet(new ulong[]{0x404012UL});
		public static readonly BitSet _QUESTION_in_field647 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ASTERISK_in_field651 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ID_in_field657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PRINTED_in_attributeDecl676 = new BitSet(new ulong[]{0x804000UL});
		public static readonly BitSet _attrType_in_attributeDecl679 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_attributeDecl681 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_attrType701 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _DOT_in_attrType706 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_attrType710 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _QUOTED_TEXT_in_attrType722 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  adt 
